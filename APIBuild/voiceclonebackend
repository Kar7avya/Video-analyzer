import express from "express";
import multer from "multer";
import fs from "fs/promises";
import supabase from "./supabaseClient.js";
import dotenv from "dotenv";
import cors from "cors";
import path from "path";

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

const upload = multer({ 
  dest: "uploads/",
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB limit
  }
});

// ----------------------
// VOICE UPLOAD
// ----------------------
async function uploadVoice(file) {
  console.log("ğŸ¤ Processing voice upload...");
  const filePath = `voices/${Date.now()}_${file.originalname}`;
  
  const bucketName = process.env.REACT_APP_SUPABASE_BUCKET;

  const { data, error } = await supabase.storage
    .from(bucketName)
    .upload(filePath, await fs.readFile(file.path), {
      cacheControl: "3600",
      upsert: false,
      contentType: file.mimetype,
    });

  await fs.unlink(file.path);

  if (error) {
    console.error("âŒ Voice upload error:", error.message);
    throw new Error(error.message);
  }

  console.log(`âœ… Voice uploaded successfully to bucket '${bucketName}':`, data.path);
  return data.path;
}

// ----------------------
// SCRIPT UPLOAD
// ----------------------
async function uploadScript(file) {
  console.log("ğŸ“œ Processing script upload...");
  const filePath = `scripts/${Date.now()}_${file.originalname}`;
  
  const bucketName = process.env.REACT_APP_SUPABASE_BUCKET;

  const { data, error } = await supabase.storage
    .from(bucketName)
    .upload(filePath, await fs.readFile(file.path), {
      cacheControl: "3600",
      upsert: false,
      contentType: file.mimetype,
    });

  await fs.unlink(file.path);

  if (error) {
    console.error("âŒ Script upload error:", error.message);
    throw new Error(error.message);
  }
  
  console.log(`âœ… Script uploaded successfully to bucket '${bucketName}':`, data.path);
  return data.path;
}

// ----------------------
// CREATE ELEVENLABS VOICE ID
// ----------------------
app.post("/create-elevenlabs-voice", express.json(), async (req, res) => {
  try {
    console.log("ğŸ—£ï¸ Request received: /create-elevenlabs-voice");
    const { voicePath } = req.body;

    if (!voicePath) {
      return res.status(400).json({ error: "Voice path is required." });
    }

    const elevenLabsApiKey = process.env.ELEVENLABS_API_KEY;
    const bucketName = process.env.REACT_APP_SUPABASE_BUCKET;
    
    // Extract voice name from path, removing timestamp and extension
    const voiceName = path.basename(voicePath)
      .split('_')
      .slice(1)
      .join('_')
      .replace(/\.[^/.]+$/, "") || `voice_${Date.now()}`;

    if (!elevenLabsApiKey) {
      return res.status(500).json({ error: "ElevenLabs API Key is missing from environment variables." });
    }

    console.log(`ğŸ¯ Using API Key: ${elevenLabsApiKey.substring(0, 20)}...`);
    console.log(`ğŸ“ Voice name: ${voiceName}`);

    // Download the uploaded audio file from Supabase
    const { data: voiceData, error: voiceDownloadError } = await supabase.storage
      .from(bucketName)
      .download(voicePath);

    if (voiceDownloadError) {
      console.error("âŒ Failed to download voice for cloning:", voiceDownloadError.message);
      return res.status(500).json({ error: "Failed to download voice file from storage." });
    }

    // Convert Blob to Buffer
    const voiceBuffer = Buffer.from(await voiceData.arrayBuffer());
    console.log(`ğŸ“Š Voice buffer size: ${voiceBuffer.length} bytes`);
    
    if (voiceBuffer.length === 0) {
      throw new Error("Downloaded voice file is empty");
    }

    // Manual multipart form data construction for ElevenLabs compatibility
    const boundary = `----WebKitFormBoundary${Math.random().toString(16).substring(2)}`;
    const CRLF = '\r\n';
    
    // Build the multipart body parts
    const textParts = [];
    const binaryParts = [];
    
    // Add name field
    textParts.push(
      `--${boundary}${CRLF}` +
      `Content-Disposition: form-data; name="name"${CRLF}${CRLF}` +
      `${voiceName}${CRLF}`
    );
    
    // Add file field header
    textParts.push(
      `--${boundary}${CRLF}` +
      `Content-Disposition: form-data; name="files"; filename="${path.basename(voicePath)}"${CRLF}` +
      `Content-Type: ${voiceData.type || 'audio/mpeg'}${CRLF}${CRLF}`
    );
    
    // Add the binary file data
    binaryParts.push(voiceBuffer);
    
    // Add closing boundary
    textParts.push(`${CRLF}--${boundary}--${CRLF}`);
    
    // Combine all parts into final body
    const bodyParts = [];
    bodyParts.push(Buffer.from(textParts[0], 'utf8'));
    bodyParts.push(Buffer.from(textParts[1], 'utf8'));
    bodyParts.push(binaryParts[0]);
    bodyParts.push(Buffer.from(textParts[2], 'utf8'));
    
    const finalBody = Buffer.concat(bodyParts);
    
    console.log(`ğŸ“¤ Sending multipart request with boundary: ${boundary}`);
    console.log(`ğŸ“Š Total body size: ${finalBody.length} bytes`);
    
    const elevenLabsResponse = await fetch(
      "https://api.elevenlabs.io/v1/voices/add",
      {
        method: "POST",
        headers: {
          "xi-api-key": elevenLabsApiKey,
          "Content-Type": `multipart/form-data; boundary=${boundary}`,
          "Accept": "application/json"
        },
        body: finalBody,
      }
    );

    const responseText = await elevenLabsResponse.text();
    console.log(`ğŸ” ElevenLabs Response Status: ${elevenLabsResponse.status}`);
    console.log(`ğŸ” Raw Response: ${responseText}`);
    
    let elevenLabsResponseJson;
    try {
      elevenLabsResponseJson = JSON.parse(responseText);
    } catch (parseError) {
      console.error("âŒ Failed to parse ElevenLabs response:", responseText);
      throw new Error(`ElevenLabs API returned invalid response: ${responseText.substring(0, 200)}`);
    }
    
    if (!elevenLabsResponse.ok) {
      console.error("âŒ ElevenLabs API error:", elevenLabsResponseJson);
      const errorMessage = elevenLabsResponseJson.detail?.message || 
                          elevenLabsResponseJson.detail || 
                          elevenLabsResponseJson.error?.message ||
                          elevenLabsResponseJson.message ||
                          `HTTP ${elevenLabsResponse.status}: ${elevenLabsResponse.statusText}`;
      throw new Error(`ElevenLabs API error: ${errorMessage}`);
    }
    
    const elevenLabsVoiceId = elevenLabsResponseJson.voice_id;
    
    if (!elevenLabsVoiceId) {
      console.error("âŒ No voice_id in response:", elevenLabsResponseJson);
      throw new Error("No voice_id returned from ElevenLabs API");
    }
    
    console.log(`âœ… New ElevenLabs Voice ID created: ${elevenLabsVoiceId}`);
    res.json({ 
      message: "Voice cloned successfully", 
      voiceId: elevenLabsVoiceId,
      voiceName: voiceName
    });

  } catch (err) {
    console.error("âŒ Error in /create-elevenlabs-voice:", err.message);
    console.error("âŒ Full error stack:", err.stack);
    res.status(500).json({ error: "Voice cloning failed: " + err.message });
  }
});

// ----------------------
// VOICE REFINEMENT (TEXT-TO-SPEECH)
// ----------------------
app.post("/refinevoice", express.json(), async (req, res) => {
  try {
    console.log("ğŸª„ Request received: /refinevoice");
    const { elevenLabsVoiceId, scriptPath, scriptContent } = req.body;

    if (!elevenLabsVoiceId || (!scriptPath && !scriptContent)) {
      return res.status(400).json({ error: "Voice ID and either a script path or content are required." });
    }

    const elevenLabsApiKey = process.env.ELEVENLABS_API_KEY;
    const bucketName = process.env.REACT_APP_SUPABASE_BUCKET;

    if (!elevenLabsApiKey) {
      return res.status(500).json({ error: "ElevenLabs API Key is missing." });
    }

    let finalScriptContent;
    if (scriptContent && scriptContent.trim()) {
        finalScriptContent = scriptContent.trim();
        console.log("âœ… Using text input for script.");
    } else if (scriptPath) {
        // Download the uploaded script file content from Supabase
        const { data: scriptData, error: scriptError } = await supabase.storage
            .from(bucketName)
            .download(scriptPath);

        if (scriptError) {
            console.error("âŒ Failed to download script:", scriptError.message);
            return res.status(500).json({ error: "Failed to download script file." });
        }
        
        // Convert Blob to text
        finalScriptContent = (await scriptData.text()).trim();
        console.log("âœ… Script content retrieved from file.");
    }

    if (!finalScriptContent) {
      return res.status(400).json({ error: "Script content is empty." });
    }

    console.log(`ğŸ“ Script content length: ${finalScriptContent.length} characters`);
    console.log(`ğŸ“„ Script preview: ${finalScriptContent.substring(0, 100)}...`);

    // ---- ELEVENLABS TEXT-TO-SPEECH API CALL ----
    console.log(`ğŸ™ï¸ Generating speech with voice ID: ${elevenLabsVoiceId}`);
    
    const requestBody = {
      text: finalScriptContent,
      model_id: "eleven_multilingual_v2",
      voice_settings: {
        stability: 0.5,
        similarity_boost: 0.8,
        style: 0.0,
        use_speaker_boost: true
      }
    };

    console.log(`ğŸ”§ TTS Request body prepared`);

    const synthesisResponse = await fetch(
      `https://api.elevenlabs.io/v1/text-to-speech/${elevenLabsVoiceId}`,
      {
        method: "POST",
        headers: {
          "xi-api-key": elevenLabsApiKey,
          "Content-Type": "application/json",
          "Accept": "audio/mpeg",
        },
        body: JSON.stringify(requestBody),
      }
    );

    console.log(`ğŸ” TTS Response Status: ${synthesisResponse.status}`);

    if (!synthesisResponse.ok) {
      const errorText = await synthesisResponse.text();
      console.error("âŒ ElevenLabs synthesis error:", errorText);
      
      let errorMessage;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.detail?.message || errorJson.detail || errorJson.message || errorText;
      } catch {
        errorMessage = errorText;
      }
      
      throw new Error(`ElevenLabs synthesis failed: ${errorMessage}`);
    }

    const refinedAudioBuffer = await synthesisResponse.arrayBuffer();
    console.log(`âœ… Voice synthesized by ElevenLabs. Audio size: ${refinedAudioBuffer.byteLength} bytes`);

    if (refinedAudioBuffer.byteLength === 0) {
      throw new Error("Generated audio file is empty");
    }

    // Create a unique filename for the refined voice
    const refinedFileName = `refinedvoice_${Date.now()}.mp3`;
    const refinedFilePath = `refinedvoices/${refinedFileName}`;

    // Upload the synthesized audio to Supabase
    const { data: refinedData, error: refinedError } = await supabase.storage
      .from(bucketName)
      .upload(refinedFilePath, Buffer.from(refinedAudioBuffer), {
        contentType: 'audio/mpeg',
        upsert: false,
      });

    if (refinedError) {
      console.error("âŒ Refined voice upload failed:", refinedError.message);
      return res.status(500).json({ error: "Failed to upload refined voice to storage." });
    }

    console.log(`âœ… Refined voice uploaded successfully to bucket '${bucketName}':`, refinedData.path);
    res.json({ 
      message: "Voice refined and uploaded successfully", 
      refinedPath: refinedData.path,
      audioSize: refinedAudioBuffer.byteLength
    });

  } catch (err) {
    console.error("âŒ Error in /refinevoice:", err.message);
    console.error("âŒ Full error:", err);
    res.status(500).json({ error: err.message });
  }
});

// ----------------------
// GET PUBLIC URL
// ----------------------
app.post("/get-public-url", express.json(), async (req, res) => {
  try {
    const { path } = req.body;
    const bucketName = process.env.REACT_APP_SUPABASE_BUCKET;

    if (!path) {
      return res.status(400).json({ error: "File path is required." });
    }

    const { data } = supabase.storage.from(bucketName).getPublicUrl(path);
    
    if (data && data.publicUrl) {
      console.log(`ğŸ”— Public URL generated for ${path}: ${data.publicUrl}`);
      return res.json({ publicUrl: data.publicUrl });
    } else {
      console.error("âŒ Failed to generate public URL for:", path);
      return res.status(500).json({ error: "Failed to get public URL." });
    }
  } catch (err) {
    console.error("âŒ Error in /get-public-url:", err.message);
    return res.status(500).json({ error: "Failed to get public URL: " + err.message });
  }
});

// ----------------------
// TEST ENDPOINT
// ----------------------
app.get("/test-api", async (req, res) => {
  try {
    const elevenLabsApiKey = process.env.ELEVENLABS_API_KEY;
    
    if (!elevenLabsApiKey) {
      return res.status(500).json({ error: "ElevenLabs API Key is missing." });
    }

    console.log(`ğŸ§ª Testing API Key: ${elevenLabsApiKey.substring(0, 20)}...`);
    
    // Test API key by getting user info
    const testResponse = await fetch("https://api.elevenlabs.io/v1/user", {
      method: "GET",
      headers: {
        "xi-api-key": elevenLabsApiKey,
      },
    });

    const testResult = await testResponse.text();
    console.log(`ğŸ” API Test Status: ${testResponse.status}`);
    console.log(`ğŸ” API Test Response: ${testResult.substring(0, 200)}...`);

    if (testResponse.ok) {
      res.json({ 
        message: "API Key is working!", 
        status: testResponse.status,
        response: JSON.parse(testResult)
      });
    } else {
      res.status(testResponse.status).json({ 
        error: "API Key test failed", 
        status: testResponse.status,
        response: testResult 
      });
    }
  } catch (err) {
    console.error("âŒ API test error:", err.message);
    res.status(500).json({ error: "API test failed: " + err.message });
  }
});

// ----------------------
// LIST VOICES ENDPOINT
// ----------------------
app.get("/list-voices", async (req, res) => {
  try {
    const elevenLabsApiKey = process.env.ELEVENLABS_API_KEY;
    
    if (!elevenLabsApiKey) {
      return res.status(500).json({ error: "ElevenLabs API Key is missing." });
    }

    const voicesResponse = await fetch("https://api.elevenlabs.io/v1/voices", {
      method: "GET",
      headers: {
        "xi-api-key": elevenLabsApiKey,
      },
    });

    const voicesData = await voicesResponse.json();
    
    if (!voicesResponse.ok) {
      throw new Error(voicesData.detail || "Failed to fetch voices");
    }

    console.log(`ğŸ“‹ Retrieved ${voicesData.voices?.length || 0} voices`);
    res.json(voicesData);
  } catch (err) {
    console.error("âŒ Error listing voices:", err.message);
    res.status(500).json({ error: "Failed to list voices: " + err.message });
  }
});

// ----------------------
// ROUTES
// ----------------------
app.post("/voiceupload", upload.single("voice"), async (req, res) => {
  try {
   console.log("âœ… Request received: /voiceupload");
   if (!req.file) return res.status(400).json({ error: "Voice file required" });

   console.log(`ğŸ“ Uploaded file: ${req.file.originalname}, size: ${req.file.size} bytes, type: ${req.file.mimetype}`);
   
   // Validate file type
   const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/m4a', 'audio/webm'];
   if (!allowedTypes.includes(req.file.mimetype)) {
     await fs.unlink(req.file.path); // Clean up
     return res.status(400).json({ error: `Unsupported file type: ${req.file.mimetype}. Please use MP3, WAV, M4A, or WebM.` });
   }
   
   const path = await uploadVoice(req.file);
   res.json({ 
     message: "Voice uploaded successfully", 
     path,
     originalName: req.file.originalname,
     size: req.file.size
   });
  } catch (err) {
   console.error("âŒ Error in /voiceupload:", err.message);
   res.status(500).json({ error: err.message });
  }
});

app.post("/scriptupload", upload.single("script"), async (req, res) => {
  try {
   console.log("âœ… Request received: /scriptupload");
   if (!req.file) return res.status(400).json({ error: "Script file required" });

   console.log(`ğŸ“ Uploaded script: ${req.file.originalname}, size: ${req.file.size} bytes, type: ${req.file.mimetype}`);
   
   // Validate file type
   const allowedTypes = ['text/plain', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
   if (!allowedTypes.includes(req.file.mimetype)) {
     await fs.unlink(req.file.path); // Clean up
     return res.status(400).json({ error: `Unsupported file type: ${req.file.mimetype}. Please use TXT, PDF, DOC, or DOCX.` });
   }
   
   const path = await uploadScript(req.file);
   res.json({ 
     message: "Script uploaded successfully", 
     path,
     originalName: req.file.originalname,
     size: req.file.size
   });
  } catch (err) {
   console.error("âŒ Error in /scriptupload:", err.message);
   res.status(500).json({ error: err.message });
  }
});

// ----------------------
// HEALTH CHECK
// ----------------------
app.get("/health", (req, res) => {
  res.json({ 
    status: "OK", 
    timestamp: new Date().toISOString(),
    apiKeyConfigured: !!process.env.ELEVENLABS_API_KEY,
    bucketConfigured: !!process.env.REACT_APP_SUPABASE_BUCKET
  });
});

// ----------------------
// ERROR HANDLING MIDDLEWARE
// ----------------------
app.use((err, req, res, next) => {
  console.error("âŒ Unhandled error:", err.message);
  console.error("âŒ Stack:", err.stack);
  res.status(500).json({ error: "Internal server error: " + err.message });
});

// ----------------------
// START SERVER
// ----------------------
const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`ğŸš€ Server running at http://localhost:${PORT}`);
  console.log("ğŸ”‘ ElevenLabs API Key configured:", process.env.ELEVENLABS_API_KEY ? "âœ… YES" : "âŒ NO");
  console.log("ğŸª£ Supabase Bucket configured:", process.env.REACT_APP_SUPABASE_BUCKET ? "âœ… YES" : "âŒ NO");
  console.log("ğŸŒ Available endpoints:");
  console.log("   GET  /health - Health check");
  console.log("   GET  /test-api - Test ElevenLabs API key");
  console.log("   GET  /list-voices - List available voices");
  console.log("   POST /voiceupload - Upload voice file");
  console.log("   POST /scriptupload - Upload script file");
  console.log("   POST /create-elevenlabs-voice - Clone voice");
  console.log("   POST /refinevoice - Generate audio with cloned voice");
  console.log("   POST /get-public-url - Get public URL for file");
});
