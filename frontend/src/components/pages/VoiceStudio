import React, { useState } from "react";
import "bootstrap/dist/css/bootstrap.min.css";

export default function VoiceUpload() {
  const [voiceFile, setVoiceFile] = useState(null);
  const [scriptFile, setScriptFile] = useState(null);
  const [scriptText, setScriptText] = useState("");
  const [useTextMode, setUseTextMode] = useState(false);
  const [logs, setLogs] = useState([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [refinedAudioPublicUrl, setRefinedAudioPublicUrl] = useState(null);

  const API_BASE_URL = "http://localhost:5000"; // Your backend URL

  const addLog = (message, type = "info") => {
    setLogs((prev) => [...prev, { message, type }]);
    console[type === "error" ? "error" : "log"](message);
  };

  const handleUpload = async () => {
    if (!voiceFile) {
      addLog("‚ùå Please select a voice file", "error");
      return;
    }
    if (!scriptFile && !scriptText.trim()) {
      addLog("‚ùå Please provide a script file or type a script", "error");
      return;
    }

    setIsProcessing(true);
    setRefinedAudioPublicUrl(null);
    addLog("üöÄ Starting the full voice synthesis workflow...");

    try {
      // Step 1: Upload voice file
      addLog("üé§ Uploading voice file...");
      const voiceFormData = new FormData();
      voiceFormData.append("voice", voiceFile);

      const voiceUploadResponse = await fetch(`${API_BASE_URL}/voiceupload`, {
        method: "POST",
        body: voiceFormData,
      });

      if (!voiceUploadResponse.ok) {
        const error = await voiceUploadResponse.json();
        throw new Error(error.error || "Voice upload failed");
      }

      const voiceUploadResult = await voiceUploadResponse.json();
      const voicePath = voiceUploadResult.path;
      addLog("‚úÖ Voice file uploaded successfully");

      // Step 2: Upload script file (if using file mode)
      let scriptPath = null;
      if (!useTextMode && scriptFile) {
        addLog("üìú Uploading script file...");
        const scriptFormData = new FormData();
        scriptFormData.append("script", scriptFile);

        const scriptUploadResponse = await fetch(`${API_BASE_URL}/scriptupload`, {
          method: "POST",
          body: scriptFormData,
        });

        if (!scriptUploadResponse.ok) {
          const error = await scriptUploadResponse.json();
          throw new Error(error.error || "Script upload failed");
        }

        const scriptUploadResult = await scriptUploadResponse.json();
        scriptPath = scriptUploadResult.path;
        addLog("‚úÖ Script file uploaded successfully");
      }

      // Step 3: Create ElevenLabs voice clone
      addLog("üó£Ô∏è Creating ElevenLabs voice clone...");
      const voiceCloneResponse = await fetch(`${API_BASE_URL}/create-elevenlabs-voice`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          voicePath: voicePath,
        }),
      });

      if (!voiceCloneResponse.ok) {
        const error = await voiceCloneResponse.json();
        throw new Error(error.error || "Voice cloning failed");
      }

      const voiceCloneResult = await voiceCloneResponse.json();
      const elevenLabsVoiceId = voiceCloneResult.voiceId;
      addLog(`‚úÖ Voice clone created with ID: ${elevenLabsVoiceId}`);

      // Step 4: Refine voice with script
      addLog("ü™Ñ Generating refined audio with script...");
      const refinePayload = {
        elevenLabsVoiceId: elevenLabsVoiceId,
      };

      if (useTextMode) {
        refinePayload.scriptContent = scriptText;
      } else {
        refinePayload.scriptPath = scriptPath;
      }

      const refineResponse = await fetch(`${API_BASE_URL}/refinevoice`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(refinePayload),
      });

      if (!refineResponse.ok) {
        const error = await refineResponse.json();
        throw new Error(error.error || "Voice refinement failed");
      }

      const refineResult = await refineResponse.json();
      const refinedPath = refineResult.refinedPath;
      addLog("‚úÖ Voice refined successfully");

      // Step 5: Get public URL for the refined audio
      addLog("üîó Getting public URL for refined audio...");
      const publicUrlResponse = await fetch(`${API_BASE_URL}/get-public-url`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          path: refinedPath,
        }),
      });

      if (!publicUrlResponse.ok) {
        const error = await publicUrlResponse.json();
        throw new Error(error.error || "Failed to get public URL");
      }

      const publicUrlResult = await publicUrlResponse.json();
      setRefinedAudioPublicUrl(publicUrlResult.publicUrl);
      addLog("‚úÖ Workflow complete! Refined audio is ready.");

    } catch (error) {
      addLog(`‚ùå Error: ${error.message}`, "error");
    } finally {
      setIsProcessing(false);
    }
  };

  const playRefinedAudio = () => {
    if (!refinedAudioPublicUrl) {
      addLog("No refined audio to play.", "error");
      return;
    }
    try {
      addLog("üéß Playing refined audio...");
      const audio = new Audio(refinedAudioPublicUrl);
      audio.play().then(() => {
        addLog("‚úÖ Audio playing successfully.");
      }).catch((err) => {
        addLog("‚ùå Error playing audio: " + err.message, "error");
      });
    } catch (err) {
      addLog("‚ùå Error playing audio: " + err.message, "error");
    }
  };

  const downloadRefinedAudio = () => {
    if (!refinedAudioPublicUrl) {
      addLog("No refined audio to download.", "error");
      return;
    }
    try {
      addLog("üíæ Downloading refined audio...");
      const link = document.createElement("a");
      link.href = refinedAudioPublicUrl;
      link.download = `refined_voice_${Date.now()}.mp3`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      addLog("‚úÖ Download started.");
    } catch (err) {
      addLog("‚ùå Error downloading audio: " + err.message, "error");
    }
  };

  return (
    <div className="container min-vh-100 d-flex justify-content-center align-items-center bg-light">
      <div className="card shadow-lg rounded-4 p-4 w-100" style={{ maxWidth: "600px" }}>
        <h2 className="text-center mb-4 text-primary fw-bold">
          üé§ Voice Cloning & Script Synthesis
        </h2>

        {/* Voice File */}
        <div className="mb-3">
          <label className="form-label fw-semibold">Select Voice File</label>
          <input
            type="file"
            accept="audio/*"
            className="form-control"
            onChange={(e) => {
              setVoiceFile(e.target.files[0]);
              addLog("üé§ Voice file selected: " + e.target.files[0]?.name);
            }}
            disabled={isProcessing}
          />
          <small className="form-text text-muted">
            Upload an audio file to clone the voice (MP3, WAV, etc.)
          </small>
        </div>

        {/* Script Mode */}
        <div className="mb-3">
          <label className="form-label fw-semibold d-block">üìú Script Mode:</label>
          <div className="form-check form-check-inline">
            <input
              type="radio"
              id="file-upload"
              name="script-mode"
              className="form-check-input"
              checked={!useTextMode}
              onChange={() => setUseTextMode(false)}
              disabled={isProcessing}
            />
            <label className="form-check-label" htmlFor="file-upload">
              File Upload
            </label>
          </div>
          <div className="form-check form-check-inline">
            <input
              type="radio"
              id="text-input"
              name="script-mode"
              className="form-check-input"
              checked={useTextMode}
              onChange={() => setUseTextMode(true)}
              disabled={isProcessing}
            />
            <label className="form-check-label" htmlFor="text-input">
              Text Input
            </label>
          </div>
        </div>

        {/* Script Input */}
        {useTextMode ? (
          <div className="mb-3">
            <label className="form-label fw-semibold">Script Text</label>
            <textarea
              value={scriptText}
              onChange={(e) => {
                setScriptText(e.target.value);
                setScriptFile(null);
              }}
              placeholder="Type your script here..."
              rows="5"
              className="form-control"
              disabled={isProcessing}
            />
            <small className="form-text text-muted">
              Enter the text you want the cloned voice to speak
            </small>
          </div>
        ) : (
          <div className="mb-3">
            <label className="form-label fw-semibold">Script File</label>
            <input
              type="file"
              accept=".txt,.doc,.docx,.pdf"
              className="form-control"
              onChange={(e) => {
                setScriptFile(e.target.files[0]);
                addLog("üìú Script file selected: " + e.target.files[0]?.name);
                setScriptText("");
              }}
              disabled={isProcessing}
            />
            <small className="form-text text-muted">
              Upload a text file containing the script
            </small>
          </div>
        )}

        {/* Upload Button */}
        <button
          onClick={handleUpload}
          disabled={isProcessing || !voiceFile || (!scriptFile && !scriptText.trim())}
          className="btn btn-primary w-100 py-2 fw-semibold mb-3"
        >
          {isProcessing ? (
            <>
              <span className="spinner-border spinner-border-sm me-2"></span>
              Processing Voice Clone...
            </>
          ) : (
            "üöÄ Clone Voice & Generate Audio"
          )}
        </button>

        {/* Audio Controls */}
        {refinedAudioPublicUrl && (
          <div className="row g-2 mb-3">
            <div className="col-6">
              <button
                onClick={playRefinedAudio}
                className="btn btn-success w-100 fw-semibold"
                disabled={isProcessing}
              >
                ‚ñ∂Ô∏è Play Audio
              </button>
            </div>
            <div className="col-6">
              <button
                onClick={downloadRefinedAudio}
                className="btn btn-outline-primary w-100 fw-semibold"
                disabled={isProcessing}
              >
                üíæ Download
              </button>
            </div>
          </div>
        )}

        {/* Audio Player */}
        {refinedAudioPublicUrl && (
          <div className="mb-3">
            <label className="form-label fw-semibold">üéß Generated Audio:</label>
            <audio controls className="w-100">
              <source src={refinedAudioPublicUrl} type="audio/mpeg" />
              Your browser does not support the audio element.
            </audio>
          </div>
        )}

        {/* Console Logs */}
        <div className="mt-4 bg-dark text-light rounded-3 p-3" style={{ height: "200px", overflowY: "auto" }}>
          <h6 className="fw-bold text-warning">üìü Console Output:</h6>
          <div className="mt-2">
            {logs.length === 0 ? (
              <small className="text-muted">No logs yet...</small>
            ) : (
              logs.map((log, index) => (
                <div
                  key={index}
                  className={`small mb-1 ${log.type === "error" ? "text-danger" : "text-success"}`}
                >
                  {log.message}
                </div>
              ))
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
